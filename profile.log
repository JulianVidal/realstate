FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000029   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    2              0.000002   endif

FUNCTION  <SNR>107_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 4 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
    4              0.000014   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    4              0.000005   endfor
                            
   16              0.000024   for matchw in g:airline_exclude_filenames
   12              0.000126     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   12              0.000005     endif
   16              0.000020   endfor
                            
    4              0.000006   if g:airline_exclude_preview && &previewwindow
                                return 1
    4              0.000004   endif
                            
    4              0.000004   return 0

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:146
Called 8 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    8              0.000019   if s:is_vim
    8              0.000028     return a:client['channel']
                              endif
                              return a:client['chan_id']

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 10 times
Total time:   0.000286
 Self time:   0.000114

count  total (s)   self (s)
   10   0.000198   0.000077   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   10   0.000083   0.000032   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 34 times
Total time:   0.001780
 Self time:   0.001212

count  total (s)   self (s)
   34   0.000540   0.000166     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
   34              0.000032     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
   34              0.000017     endif
                            
   34              0.000054     let self._bookmarkNames = []
   34   0.000331   0.000137     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
   34              0.000033     endfor
   34              0.000078     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
   34              0.000022     endif
                            
   34              0.000031     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
   34              0.000017     endif
                            
   34              0.000031     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
   34              0.000014     endif

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:211
Called 2 times
Total time:   0.000385
 Self time:   0.000385

count  total (s)   self (s)
    2              0.000012   let winid = a:winid == 0 ? win_getid() : a:winid
    2              0.000038   if empty(getwininfo(winid))
                                " not valid
                                return
    2              0.000002   endif
    2              0.000023   if s:clear_match_by_window
    2              0.000127     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
   20              0.000032     for item in arr
   18              0.000064       call matchdelete(item['id'], winid)
   20              0.000011     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
    2              0.000001   endif

FUNCTION  <SNR>50_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:544
Called 68 times
Total time:   0.000471
 Self time:   0.000471

count  total (s)   self (s)
   68              0.000104   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
   68              0.000040   else
   68              0.000081     let artifactFix = ''
   68              0.000034   endif
                            
   68              0.000066   return artifactFix

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 4 times
Total time:   0.004275
 Self time:   0.000529

count  total (s)   self (s)
   30              0.000049     for Fn in a:list
   30   0.004106   0.000360       let code = call(Fn, a:000)
   30              0.000041       if code != 0
    4              0.000004         return code
   26              0.000020       endif
   26              0.000018     endfor
                                return 0

FUNCTION  <SNR>132_getStatusKey()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:149
Called 12 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   12              0.000027     let l:xy = a:x . a:y
   12              0.000031     if get(s:unmerged_status, l:xy, 0)
                                    return 'Unmerged'
   12              0.000016     elseif l:xy ==# '??'
                                    return 'Untracked'
   12              0.000014     elseif l:xy ==# '!!'
                                    return 'Ignored'
   12              0.000015     elseif a:y ==# 'M'
   12              0.000012         return 'Modified'
                                elseif a:y ==# 'D'
                                    return 'Deleted'
                                elseif a:y =~# '[RC]'
                                    return 'Renamed'
                                elseif a:x ==# 'D'
                                    return 'Deleted'
                                elseif a:x =~# '[MA]'
                                    return 'Staged'
                                elseif a:x =~# '[RC]'
                                    return 'Renamed'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 10 times
Total time:   0.000283
 Self time:   0.000065

count  total (s)   self (s)
   10   0.000276   0.000058   return airline#extensions#coc#get('error')

FUNCTION  <SNR>52_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 16 times
Total time:   0.002345
 Self time:   0.000235

count  total (s)   self (s)
   16   0.002344   0.000234   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>52_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 34 times
Total time:   0.004380
 Self time:   0.004380

count  total (s)   self (s)
   34              0.003389   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   34              0.000788   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   34              0.000133   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:199
Called 14 times
Total time:   0.040508
 Self time:   0.001780

count  total (s)   self (s)
   14              0.000042   if !has_key(s:contexts, a:winnr)
                                return ''
   14              0.000013   endif
   14              0.000042   let context = s:contexts[a:winnr]
                            
   14              0.000096   if get(w:, 'airline_active', 1)
   10              0.000026     let l:m = mode(1)
   10              0.000016     if l:m ==# "i"
                                  let l:mode = ['insert']
   10              0.000022     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
   10              0.000011     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   10              0.000015     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   10              0.000078     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   10              0.000011     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   10              0.000016     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
   10              0.000012     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   10              0.000021     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
   10              0.000006     else
   10              0.000023       let l:mode = ['normal']
   10              0.000006     endif
   10              0.000056     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   10              0.000007     endif
   10              0.000062     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   10              0.000024       let l:m = l:m[0]
   10              0.000006     endif
   10              0.000056     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    4              0.000003   else
    4              0.000009     let l:mode = ['inactive']
    4              0.000024     let w:airline_current_mode = get(g:airline_mode_map, '__')
   14              0.000010   endif
                            
   14              0.000044   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
   14              0.000005   endif
                            
   14              0.000019   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   14              0.000005   endif
                            
   14              0.000058   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   14              0.000006   endif
                            
   14              0.000023   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   14              0.000007   endif
                            
   14              0.000022   if &readonly || ! &modifiable
    4              0.000012     call add(l:mode, 'readonly')
   14              0.000006   endif
                            
   14              0.000064   let mode_string = join(l:mode)
   14              0.000059   if get(w:, 'airline_lastmode', '') != mode_string
    2   0.000612   0.000014     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    2   0.037958   0.000080     call airline#highlighter#highlight(l:mode, context.bufnr)
    2   0.000264   0.000012     call airline#util#doautocmd('AirlineModeChanged')
    2              0.000004     let w:airline_lastmode = mode_string
   14              0.000005   endif
                            
   14              0.000014   return ''

FUNCTION  <SNR>52_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 14 times
Total time:   0.002812
 Self time:   0.000570

count  total (s)   self (s)
   14   0.002806   0.000564   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 70 times
Total time:   0.000758
 Self time:   0.000758

count  total (s)   self (s)
   70              0.000160   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   70              0.000031   endif
   70              0.000220   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   70              0.000213   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/vimtex.vim:44
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000007   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
    2              0.000001   endif

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:203
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    2              0.000014   let dt = localtime() - s:focusgained_ignore_time
    2              0.000015   let s:focusgained_ignore_time = 0
    2              0.000004   return dt >= 1

FUNCTION  <SNR>138_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 8 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    8              0.000019   return a:from_count == 0 && a:to_count > 0

FUNCTION  318()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:114
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000041   return eval(a:expr)

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 72 times
Total time:   0.014544
 Self time:   0.000783

count  total (s)   self (s)
   72   0.014519   0.000758   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:279
Called 2 times
Total time:   0.000093
 Self time:   0.000080

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    2              0.000035   let g:airline#visual_active = (mode() =~? '[vs]')
    2   0.000054   0.000041   call airline#update_tabline()

FUNCTION  <SNR>137_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 2 times
Total time:   0.000039
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000039   0.000012   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 10 times
Total time:   0.000368
 Self time:   0.000104

count  total (s)   self (s)
   10   0.000356   0.000092   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:46
Called 10 times
Total time:   0.000382
 Self time:   0.000093

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
   10   0.000369   0.000080   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:47
Called 88 times
Total time:   0.001480
 Self time:   0.000967

count  total (s)   self (s)
   88   0.000923   0.000410     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
   88              0.000048     endif
                            
   88              0.000069     return '/'

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:804
Called 2 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000003   let invalids = []
    2              0.000002   if s:is_vim
    2              0.000006     if !exists('*popup_list')
                                  return
    2              0.000001     endif
    2              0.000008     for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
    2              0.000003     endfor
                              else
                                for i in range(1, winnr('$'))
                                  let target = getwinvar(i, 'target_winid', 0)
                                  if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
                                  elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
                                  endif
                                endfor
    2              0.000001   endif
    2              0.000002   for id in invalids
                                call coc#float#close(id)
    2              0.000002   endfor

FUNCTION  <SNR>52_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000013   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>115_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 10 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   10              0.000074   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 2 times
Total time:   0.000345
 Self time:   0.000345

count  total (s)   self (s)
    2              0.000278   let p = resolve(expand('#'.a:bufnr.':p'))
    2              0.000030   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    2              0.000007   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    2              0.000019   endif
    2              0.000003   return g:gitgutter_diff_base

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 10 times
Total time:   0.000203
 Self time:   0.000114

count  total (s)   self (s)
   10   0.000193   0.000104   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000012   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    2              0.000002   endif

FUNCTION  <SNR>126_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 16 times
Total time:   0.019782
 Self time:   0.000305

count  total (s)   self (s)
   16   0.006820   0.000151   if airline#builder#should_change_group(a:prev_group, a:group)
   16   0.012946   0.000138     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 10 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   10              0.000039   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   10              0.000005   endif
   10              0.000005   return ''

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:273
Called 6 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    6              0.000021   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
    6              0.000002   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000016   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    2              0.000001   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:102
Called 104 times
Total time:   0.029891
 Self time:   0.006800

count  total (s)   self (s)
  104              0.000172   if pumvisible()
                                return
  104              0.000050   endif
  104              0.000173   let colors = a:colors
  104              0.000115   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  104              0.000056   endif
  104   0.019985   0.000920   let old_hi = airline#highlighter#get_highlight(a:group)
  104              0.000239   if len(colors) == 4
   36              0.000119     call add(colors, '')
  104              0.000065   endif
  104              0.001019   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  104   0.003188   0.000728   let colors = s:CheckDefined(colors)
  104   0.002505   0.000939   if old_hi != new_hi || !s:hl_group_exists(a:group)
                                let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                exe cmd
                                if has_key(s:hl_groups, a:group)
                                  let s:hl_groups[a:group] = colors
                                endif
  104              0.000062   endif

FUNCTION  <SNR>114_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:26
Called 66 times
Total time:   0.000498
 Self time:   0.000498

count  total (s)   self (s)
   66              0.000214   if index(a:list, a:name) == -1
   66              0.000181     call add(a:list, a:name)
   66              0.000063     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  <SNR>127_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 30 times
Total time:   0.001307
 Self time:   0.001052

count  total (s)   self (s)
   30              0.000084   if has_key(s:section_truncate_width, a:key)
   18   0.000291   0.000134     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    2              0.000001       return ''
   16              0.000005     endif
   28              0.000019   endif
   28              0.000048   let spc = g:airline_symbols.space
   28              0.000106   if !exists('g:airline_section_{a:key}')
                                return ''
   28              0.000011   endif
   28   0.000340   0.000242   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   28              0.000172   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   28              0.000099   return empty(text) ? '' : prefix.text.suffix

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 4 times
Total time:   0.058545
 Self time:   0.000463

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    4   0.001477   0.000031   if gitgutter#utility#is_active(a:bufnr)
                            
    4              0.000017     if has('patch-7.4.1559')
    4              0.000026       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    4              0.000003     endif
    4   0.000215   0.000029     let how = s:setup_path(a:bufnr, l:Callback)
    4              0.000012     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
    4              0.000003     endif
                            
    4   0.000051   0.000019     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000003       let diff = 'NOT SET'
    2              0.000001       try
    2   0.056596   0.000178         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    2              0.000002       endtry
                            
    2              0.000007       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    2              0.000001       endif
                            
    4              0.000001     endif
    4              0.000002   endif

FUNCTION  <SNR>52_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 2 times
Total time:   0.000227
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000227   0.000017   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 20 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
   20              0.000078   if !exists(':CocCommand')
                                return ''
   20              0.000011   endif
   20              0.000062   let _backup = get(g:, 'coc_stl_format', '')
   20              0.000040   let is_err = (a:type  is# 'error')
   20              0.000017   if is_err
   10              0.000032     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
   10              0.000004   else
   10              0.000032     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
   20              0.000011   endif
   20              0.000054   let info = get(b:, 'coc_diagnostic_info', {})
   20              0.000051   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                let lnum = printf('(L%d)', (info.lnums)[0])
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>55_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 2 times
Total time:   0.032899
 Self time:   0.000088

count  total (s)   self (s)
    2   0.000065   0.000022   if airline#util#try_focusgained()
    2   0.032827   0.000059     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    2              0.000001   endif

FUNCTION  <SNR>20_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:186
Called 8 times
Total time:   0.000531
 Self time:   0.000470

count  total (s)   self (s)
    8   0.000141   0.000080   let channel = coc#client#get_channel(self)
    8              0.000015   if empty(channel)
                                return ''
    8              0.000005   endif
    8              0.000006   try
    8              0.000006     if s:is_vim
    8              0.000125       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
                                else
                                  call call('rpcnotify', [channel, a:method] + a:args)
    8              0.000001     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
    8              0.000007   endtry

FUNCTION  302()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:88
Called 2 times
Total time:   0.001282
 Self time:   0.001282

count  total (s)   self (s)
    2              0.000040         let options = { 'out_cb':   { _ch, data -> self.onStdoutCB([data]) }, 'err_cb':   { _ch, data -> self.onStderrCB([data]) }, 'close_cb': { _ch -> self.onExitCB() }, 'out_mode': 'nl', 'err_mode': 'nl', 'env':      {'GIT_OPTIONAL_LOCKS': '0'}, }
    2              0.000006         if has('patch-8.1.350')
    2              0.000004             let options['noblock'] = 1
    2              0.000000         endif
    2              0.001167         let jid = job_start(a:cmd, options)
    2              0.000029         if job_status(jid) ==# 'run'
    2              0.000005             let self.id = jid
    2              0.000002             let self.running = 1
                                    else
                                        let self.running = 0
                                        let self.failed = 1
                                        let self.err_chunks = ['failed to start job']
                                        call self.onExitCB()
    2              0.000001         endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 4 times
Total time:   0.000522
 Self time:   0.000263

count  total (s)   self (s)
    4              0.000026   let filetype_overrides = get(s:, 'filetype_overrides', {})
    4              0.000026   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    4   0.000289   0.000030   if s:is_excluded_window()
                                return -1
    4              0.000001   endif
                            
    4              0.000008   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    4              0.000002   endif
                            
    4              0.000013   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    4              0.000001   endif
                            
    4              0.000028   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    4              0.000002   endif
                            
    4              0.000006   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    4              0.000004   endif
                            
    4              0.000017   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    4              0.000004   endfor

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 4 times
Total time:   0.000142
 Self time:   0.000051

count  total (s)   self (s)
    4   0.000133   0.000042   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  12()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 20 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   20              0.000029     if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
   20              0.000005     endif
                            
   20              0.000018     return self.cachedDisplayString

FUNCTION  19()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 96 times
Total time:   0.001009
 Self time:   0.001009

count  total (s)   self (s)
   96              0.000183     if empty(self.pathSegments)
                                    return ''
   96              0.000078     endif
   96              0.000197     let toReturn = self.pathSegments[-1]
   96              0.000145     if a:dirSlash && self.isDirectory
   12              0.000019         let toReturn = toReturn . '/'
   96              0.000061     endif
   96              0.000098     return toReturn

FUNCTION  <SNR>114_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:93
Called 104 times
Total time:   0.001566
 Self time:   0.001566

count  total (s)   self (s)
  104              0.000469   if !hlexists(a:group)
                                return 0
  104              0.000630   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  104              0.000054   endif
  104              0.000104   return 1

FUNCTION  311()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:75
Called 2 times
Total time:   0.002161
 Self time:   0.000161

count  total (s)   self (s)
    2              0.000004   let res = []
    8              0.000035   for [key, arglist] in a:calls
    6              0.000018     let name = key[5:]
    6              0.000004     try
    6   0.002056   0.000056       call add(res, call(s:funcs[name], arglist))
                                catch /.*/
                                  return [res, v:exception]
    6              0.000006     endtry
    8              0.000007   endfor
    2              0.000003   return [res, v:null]

FUNCTION  317()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:105
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                              " command that could cause cursor vanish
    2              0.000017   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
    2              0.000017     call timer_start(0, {-> s:execute(a:command)})
                              else
                                execute a:command
    2              0.000002   endif

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:54
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000010   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    2              0.000003   endif

FUNCTION  24()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:432
Called 30 times
Total time:   0.000459
 Self time:   0.000168

count  total (s)   self (s)
   30   0.000454   0.000163     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 32 times
Total time:   0.003524
 Self time:   0.001383

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   32   0.000125   0.000081     if a:nerdtree.ui.isIgnoreFilterEnabled()
   62              0.000099         for i in g:NERDTreeIgnore
   32   0.001505   0.000109             if self._ignorePatternMatches(i)
    2              0.000001                 return 1
   30              0.000036             endif
   60              0.000045         endfor
                            
   30   0.000308   0.000130         for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
   30              0.000033         endfor
   30              0.000015     endif
                            
                                "dont show hidden files unless instructed to
   30   0.000693   0.000197     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   10              0.000007         return 1
   20              0.000006     endif
                            
   20   0.000089   0.000062     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
   20              0.000008     endif
                            
   20              0.000013     return 0

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:484
Called 32 times
Total time:   0.001396
 Self time:   0.001052

count  total (s)   self (s)
   32              0.000043     let pat = a:pattern
   32              0.000106     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                    let pat = strpart(pat,0, len(pat)-8)
                                    return self.str() =~# pat
   32              0.000116     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
   32              0.000115     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
   32              0.000014     endif
                            
   32   0.000545   0.000201     return self.getLastPathComponent(0) =~# pat

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 2 times
Total time:   0.000617
 Self time:   0.000047

count  total (s)   self (s)
    2   0.000272   0.000030   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    2   0.000343   0.000015   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>138_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 2 times
Total time:   0.052472
 Self time:   0.052472

count  total (s)   self (s)
    2              0.000127   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    2              0.000008   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    2              0.000001   endif
                            
    2              0.000009   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    2              0.000001   endif
                            
    2              0.000006   if getbufvar(a:bufnr, '&endofline')
    2              0.000005     call add(bufcontents, '')
    2              0.000002   endif
                            
    2              0.000006   let fenc = getbufvar(a:bufnr, '&fileencoding')
    2              0.000003   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    2              0.000000   endif
                            
    2              0.000006   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    2              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    2              0.000002   try
    2              0.052196     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    2              0.000004   endtry

FUNCTION  112()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 8 times
Total time:   0.001385
 Self time:   0.000049

count  total (s)   self (s)
    8   0.001383   0.000047     return self.path.str() ==# a:treenode.path.str()

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 74 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   74              0.000072     return self._nerdtree

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 118 times
Total time:   0.001125
 Self time:   0.001125

count  total (s)   self (s)
  118              0.000343   let nr = get(a:000, 0, 0)
  118              0.000291   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  118              0.000064   else
  118              0.000213     return winwidth(nr)
                              endif

FUNCTION  <SNR>127_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 6 times
Total time:   0.002337
 Self time:   0.000381

count  total (s)   self (s)
   28              0.000033   for key in a:keys
   22              0.000062     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   22              0.000013     endif
   22   0.002151   0.000195     call s:add_section(a:builder, a:context, key)
   28              0.000020   endfor

FUNCTION  <SNR>107_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000009   if !exists('w:airline_section_{a:name}')
    2              0.000009     let w:airline_section_{a:name} = g:airline_section_{a:name}
    2              0.000000   endif

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 4 times
Total time:   0.000642
 Self time:   0.000338

count  total (s)   self (s)
    4   0.000637   0.000333   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  36()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:648
Called 34 times
Total time:   0.022342
 Self time:   0.000309

count  total (s)   self (s)
   34   0.020454   0.000201     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
   34   0.001874   0.000094     call self.cacheDisplayString()

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 90 times
Total time:   0.008022
 Self time:   0.004272

count  total (s)   self (s)
   90              0.000178     let options = a:0 ? a:1 : {}
   90              0.000104     let toReturn = ''
                            
   90              0.000183     if has_key(options, 'format')
    2              0.000004         let format = options['format']
    2              0.000006         if has_key(self, '_strFor' . format)
    2   0.000040   0.000018             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
    2              0.000001         endif
   88              0.000046     else
   88   0.003778   0.000350         let toReturn = self._str()
   90              0.000049     endif
                            
   90   0.000673   0.000373     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
   90              0.000044     endif
                            
   90              0.000169     if has_key(options, 'truncateTo')
    2              0.000004         let limit = options['truncateTo']
    2              0.000006         if strdisplaywidth(toReturn) > limit-1
   16              0.000055             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   14              0.000059                 let toReturn = substitute(toReturn, '^.', '', '')
   16              0.000013             endwhile
    2              0.000012             if len(split(toReturn, '/')) > 1
    2              0.000019                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    2              0.000000             endif
    2              0.000002         endif
   90              0.000032     endif
                            
   90              0.000081     return toReturn

FUNCTION  39()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:735
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000009     let toReturn = '/' . join(self.pathSegments, '/')
    2              0.000004     if self.isDirectory && toReturn !=# '/'
    2              0.000004         let toReturn  = toReturn . '/'
    2              0.000002     endif
    2              0.000002     return toReturn

FUNCTION  331()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:167
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006   return win_getid()

FUNCTION  gitstatus#util#FormatPath()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:45
Called 34 times
Total time:   0.003144
 Self time:   0.000130

count  total (s)   self (s)
   34   0.003141   0.000127         return a:path.str()

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 2 times
Total time:   0.007409
 Self time:   0.000015

count  total (s)   self (s)
    2   0.007408   0.000014     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 22 times
Total time:   0.010246
 Self time:   0.007888

count  total (s)   self (s)
   22              0.000024     let output = ''
   22              0.000024     if a:drawText ==# 1
                            
   20              0.000049         let treeParts = repeat('  ', a:depth - 1)
   20              0.000059         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
   20   0.002277   0.000094         let line = treeParts . self.displayString()
   20              0.000041         let output = output . line . "\n"
   22              0.000006     endif
                            
                                " if the node is an open dir, draw its children
   22              0.000030     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    2   0.003943   0.000011         let childNodesToDraw = self.getVisibleChildren()
                            
    2   0.000423   0.000012         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
    2              0.000004         elseif len(childNodesToDraw) > 0
   22              0.000018             for i in childNodesToDraw
   20              0.000055                 let output = output . i._renderToString(a:depth + 1, 1)
   22              0.000009             endfor
    2              0.000002         endif
   22              0.000009     endif
                            
   22              0.000017     return output

FUNCTION  138()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 6 times
Total time:   0.001768
 Self time:   0.000236

count  total (s)   self (s)
    6              0.000007     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
    6              0.000006     let l:label = ''
    6   0.001395   0.000020     let l:cascade = self.getCascade()
   12              0.000015     for l:dirNode in l:cascade
    6   0.000058   0.000026         let l:next = l:dirNode.path.displayString()
    6              0.000026         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
   12              0.000010     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
    6              0.000023     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
    6              0.000017     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
    6   0.000151   0.000026     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
    6              0.000012     return l:symbol . l:flags . l:label

FUNCTION  301()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:63
Called 2 times
Total time:   0.002315
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000006     if has_key(self.opts, 'on_success_cb')
    2   0.002304   0.000024         call call(self.opts.on_success_cb, [self])
    2              0.000001     endif

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 2 times
Total time:   0.000526
 Self time:   0.000175

count  total (s)   self (s)
    2              0.000003   let hunks = []
   10              0.000028   for line in split(a:diff, '\n')
    8   0.000427   0.000076     let hunk_info = gitgutter#diff#parse_hunk(line)
    8              0.000018     if len(hunk_info) == 4
    8              0.000019       call add(hunks, hunk_info)
    8              0.000005     endif
   10              0.000009   endfor
    2              0.000002   return hunks

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 6 times
Total time:   0.001375
 Self time:   0.000026

count  total (s)   self (s)
    6   0.001367   0.000018     if !self.isCascadable()
    6              0.000007         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 2 times
Total time:   0.002091
 Self time:   0.000117

count  total (s)   self (s)
    2              0.000003   let modified_lines = []
   10              0.000012   for hunk in a:hunks
    8   0.002054   0.000080     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   10              0.000010   endfor
    2              0.000003   return modified_lines

FUNCTION  <SNR>55_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 2 times
Total time:   0.032768
 Self time:   0.000143

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000016   let fast=!empty(get(a:000, 0, 0))
    2              0.000009   if !exists("#airline")
                                " disabled
                                return
    2              0.000001   endif
    2   0.000418   0.000028   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.000691   0.000026   call airline#highlighter#reset_hlcache()
    2              0.000007   if !fast
                                call airline#load_theme()
    2              0.000001   endif
    2   0.031586   0.000026   call airline#update_statusline()
    2   0.000025   0.000015   call airline#update_tabline()

FUNCTION  <SNR>138_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000002   let offset = 0
    4              0.000006   while offset < a:to_count
    2              0.000004     let line_number = a:to_line + offset
    2              0.000006     call add(a:modifications, [line_number, 'added'])
    2              0.000004     let offset += 1
    4              0.000004   endwhile

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 30 times
Total time:   0.000951
 Self time:   0.000610

count  total (s)   self (s)
   30   0.000624   0.000283   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
   30              0.000012   else
   30              0.000028     return a:text
                              endif

FUNCTION  150()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 8 times
Total time:   0.003990
 Self time:   0.000431

count  total (s)   self (s)
    8              0.000009     let toReturn = []
   40              0.000041     for i in self.children
   32   0.003752   0.000193         if i.path.ignore(self.getNerdtree()) ==# 0
   20              0.000047             call add(toReturn, i)
   32              0.000017         endif
   40              0.000025     endfor
    8              0.000006     return toReturn

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 8 times
Total time:   0.001760
 Self time:   0.000159

count  total (s)   self (s)
    8              0.000011     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
    8              0.000004     endif
                            
    8   0.001533   0.000022     if self.isRoot()
    2              0.000001         return 0
    6              0.000002     endif
                            
    6              0.000006     if self.path.isSymLink
                                    return 0
    6              0.000004     endif
                            
    6   0.000051   0.000019     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
    6              0.000007     endfor
                            
    6   0.000074   0.000016     let c = self.getVisibleChildren()
    6              0.000014     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  <SNR>139_execute()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:29
Called 2 times
Total time:   0.002053
 Self time:   0.002053

count  total (s)   self (s)
    2              0.000010   if a:cmd =~# '^echo'
                                execute a:cmd
    2              0.000001   else
    2              0.002032     silent! execute a:cmd
    2              0.000005   endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 4 times
Total time:   0.002718
 Self time:   0.000209

count  total (s)   self (s)
    4              0.000009   let winnr = a:context.winnr
    4              0.000005   let active = a:context.active
                            
    4   0.000046   0.000032   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.001151   0.000040     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    4              0.000001   endif
                            
    4   0.000182   0.000036   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    4   0.000029   0.000017   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.001240   0.000014     call s:build_sections(a:builder, a:context, s:layout[1])
    4              0.000003   endif
                            
    4              0.000003   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:185
Called 6 times
Total time:   0.000190
 Self time:   0.000119

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    6   0.000179   0.000108   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  gitstatus#getIndicator()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:61
Called 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    4              0.000026     return get(get(g:, 'NERDTreeGitStatusIndicatorMapCustom', {}), a:status, s:indicatorMap[a:status])

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:187
Called 2 times
Total time:   0.008324
 Self time:   0.000012

count  total (s)   self (s)
    2   0.008323   0.000011     call nerdtree#renderView()

FUNCTION  162()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:599
Called 12 times
Total time:   0.029457
 Self time:   0.006139

count  total (s)   self (s)
   12   0.008316   0.000075     call self.path.refreshFlags(self.getNerdtree())
   44              0.000081     for i in self.children
   32   0.014425   0.000122         call i.refreshFlags()
   44              0.000031     endfor

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:214
Called 18 times
Total time:   0.013885
 Self time:   0.000387

count  total (s)   self (s)
   18              0.000173   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   18   0.013700   0.000202   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  coc#highlight#match_ranges()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:161
Called 2 times
Total time:   0.001463
 Self time:   0.001463

count  total (s)   self (s)
    2              0.000005   let winid = a:winid == 0 ? win_getid() : a:winid
    2              0.000005   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    2              0.000020   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    2              0.000002   endif
    2              0.000003   if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
    2              0.000000   endif
    2              0.000002   let ids = []
   20              0.000017   for range in a:ranges
   18              0.000025     let list = []
   18              0.000026     let start = range['start']
   18              0.000019     let end = range['end']
   36              0.000075     for lnum in range(start['line'] + 1, end['line'] + 1)
   18              0.000050       let arr = getbufline(bufnr, lnum)
   18              0.000048       let line = empty(arr) ? '' : arr[0]
   18              0.000029       if empty(line)
                                    continue
   18              0.000014       endif
   18              0.000083       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
   18              0.000094       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
   18              0.000018       if colStart == colEnd
                                    continue
   18              0.000006       endif
   18              0.000053       call add(list, [lnum, colStart, colEnd - colStart])
   36              0.000024     endfor
   18              0.000023     if !empty(list)
   18              0.000057       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
   18              0.000183       let id = matchaddpos(a:hlGroup, list, a:priority, -1, opts)
   18              0.000038       call add(ids, id)
   18              0.000010     endif
   20              0.000014   endfor
    2              0.000003   if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
    2              0.000001   endif
    2              0.000001   return ids

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:604
Called 34 times
Total time:   0.012636
 Self time:   0.003183

count  total (s)   self (s)
   34              0.000048   let path = a:event.subject
   34              0.000057   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
   34              0.000057   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
   34   0.000356   0.000158   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
   34              0.000112   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
   34   0.000470   0.000242   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
   34              0.000070   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
   30              0.000062     let prePadding .= ' '
   34              0.000014   endif
                            
   34              0.000036   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
   22   0.005536   0.000233     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
   12              0.000022   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
   12              0.000013     let directoryOpened = 0
                            
   12              0.000036     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
   12              0.000006     endif
                            
   12              0.000015     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
   12              0.000014       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
   12              0.000007       else
                                    " the folder is not open
   12              0.000012         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
   12              0.000006         else
                                      " We have a regular folder
   12   0.003183   0.000147           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
   12              0.000006         endif
   12              0.000008       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
   12              0.000005     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
   34              0.000020   endif
                            
   34   0.000264   0.000137   call path.flagSet.clearFlags('webdevicons')
                            
   34              0.000049   if flag !=? ''
   34   0.000684   0.000123     call path.flagSet.addFlag('webdevicons', flag)
   34              0.000017   endif
                            

FUNCTION  81()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 40 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   40              0.000094     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
   40              0.000020     endif
   40              0.000054     return g:NERDTreeBookmarks

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 94 times
Total time:   0.000616
 Self time:   0.000541

count  total (s)   self (s)
   94   0.000327   0.000252   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   94              0.000054   endif
   94              0.000104   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 4 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    4              0.000005   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    4              0.000002   endif

FUNCTION  <SNR>70_Remove_Matches()
    Defined: /usr/local/Cellar/vim/8.2.2475/share/vim/vim82/plugin/matchparen.vim:196
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000006   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    2              0.000002   endif

FUNCTION  <SNR>126_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 18 times
Total time:   0.014640
 Self time:   0.000755

count  total (s)   self (s)
   18              0.000027   let line = ''
   18              0.000086   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   18              0.000013   else
   18   0.014099   0.000214     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   18              0.000091     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   18              0.000094     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   18              0.000047     let line .= '%#'.a:group.'#'
   18              0.000011   endif
   18              0.000020   return line

FUNCTION  315()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:97
Called 4 times
Total time:   0.001954
 Self time:   0.000106

count  total (s)   self (s)
    4   0.001952   0.000104   return call(a:method, a:args)

FUNCTION  gitstatus#job#Spawn()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:132
Called 2 times
Total time:   0.001393
 Self time:   0.000087

count  total (s)   self (s)
    2   0.000034   0.000010     let l:job = s:newJob(a:name, a:opts)
    2   0.001330   0.000048     call l:job.run(a:cmd)
    2              0.000010     return l:job

FUNCTION  <SNR>52_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 14 times
Total time:   0.002246
 Self time:   0.000229

count  total (s)   self (s)
   14   0.002241   0.000224   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 2 times
Total time:   0.000033
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000032   0.000012   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>138_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000011   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>50_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:399
Called 2 times
Total time:   0.031560
 Self time:   0.000117

count  total (s)   self (s)
    2              0.000007   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    2              0.000001   endif
                            
    2   0.000072   0.000016   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
    2              0.000001   endif
                            
                              " Do not update when a special buffer is selected
    2              0.000007   if !empty(&l:buftype)
                                return
    2              0.000001   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
    2              0.000006   let l:winnr = winnr()
    2              0.000006   let l:altwinnr = winnr('#')
                            
    2   0.000189   0.000012   call g:NERDTree.CursorToTreeWin()
    2   0.022899   0.000013   call b:NERDTree.root.refreshFlags()
    2   0.008336   0.000012   call NERDTreeRender()
                            
    2              0.000011   exec l:altwinnr . 'wincmd w'
    2              0.000009   exec l:winnr . 'wincmd w'

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:127
Called 2 times
Total time:   0.031560
 Self time:   0.000221

count  total (s)   self (s)
    2   0.000127   0.000057   if airline#util#stl_disabled(winnr())
                                return
    2              0.000000   endif
    2              0.000023   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    2   0.008080   0.000047   call airline#update_statusline_inactive(range)
                            
    2              0.000004   unlet! w:airline_render_left w:airline_render_right
    2              0.000024   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    2              0.000002   let w:airline_active = 1
    2              0.000012   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.023275   0.000039   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>117_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:185
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000007   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000002     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>138_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 10 times
Total time:   0.005557
 Self time:   0.000389

count  total (s)   self (s)
   10              0.000068   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   10              0.000004   endif
   10   0.005269   0.000101   return {b:source_func}()

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 4 times
Total time:   0.000233
 Self time:   0.000085

count  total (s)   self (s)
    4   0.000124   0.000042   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000010   let summary[1] += a:count
    4   0.000095   0.000029   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>138_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 6 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    6              0.000014   return a:from_count > 0 && a:to_count == 0

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:146
Called 2 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    2              0.000018   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    2              0.000003   endif

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:202
Called 176 times
Total time:   0.000964
 Self time:   0.000964

count  total (s)   self (s)
  176              0.000915     return has('win16') || has('win32') || has('win64')

FUNCTION  282()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:105
Called 60 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
   60              0.000189     return get(self.opts, 'NERDTreeGitStatus' . a:name, a:default)

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 2 times
Total time:   0.058153
 Self time:   0.000485

count  total (s)   self (s)
    2              0.000010   let visible = tabpagebuflist()
                            
    8              0.000043   for bufnr in range(1, bufnr('$') + 1)
    6              0.000017     if buflisted(bufnr)
    2              0.000187       let file = expand('#'.bufnr.':p')
    2              0.000010       if !empty(file)
    2              0.000010         if index(visible, bufnr) != -1
    2   0.057737   0.000069           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    2              0.000002         endif
    2              0.000000       endif
    6              0.000008     endif
    8              0.000013   endfor

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 2 times
Total time:   0.000218
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000218   0.000015   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000009   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    2              0.000002   endif

FUNCTION  111()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 14 times
Total time:   0.000415
 Self time:   0.000086

count  total (s)   self (s)
   14   0.000412   0.000083     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:237
Called 2 times
Total time:   0.037878
 Self time:   0.005258

count  total (s)   self (s)
    2              0.000005   let bufnr = a:0 ? a:1 : ''
    2              0.000006   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    2              0.000015   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    2              0.000004   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    2              0.000004   let airline_grouplist = []
    2              0.000008   let buffers_in_tabpage = sort(tabpagebuflist())
    2              0.000005   if exists("*uniq")
    2              0.000005     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    2              0.000001   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
    4              0.000008   for mode in reverse(mapped)
    2              0.000013     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    2              0.000006       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   38              0.000076       for kvp in items(dict)
   36              0.000075         let mode_colors = kvp[1]
   36              0.000058         let name = kvp[0]
   36              0.000096         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
   36              0.000022         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
   36              0.000233         if name =~# 'airline_c\d\+'
    4              0.000035           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    4              0.000014           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
    4              0.000001           endif
   32              0.000197         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   14              0.000012           continue
   22              0.000010         endif
   22   0.000349   0.000185         if s:group_not_done(airline_grouplist, name.suffix)
   22   0.006580   0.000172           call airline#highlighter#exec(name.suffix, mode_colors)
   22              0.000014         endif
                            
   22              0.000069         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
   22              0.000015         endif
                            
   66              0.000116         for accent in keys(s:accents)
   44              0.000101           if !has_key(p.accents, accent)
                                        continue
   44              0.000036           endif
   44              0.000169           let colors = copy(mode_colors)
   44              0.000122           if p.accents[accent][0] != ''
   22              0.000060             let colors[0] = p.accents[accent][0]
   44              0.000042           endif
   44              0.000115           if p.accents[accent][2] != ''
   22              0.000048             let colors[2] = p.accents[accent][2]
   44              0.000024           endif
   44              0.000093           if len(colors) >= 5
   44              0.000163             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
   44              0.000028           endif
   44   0.000711   0.000377           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   44   0.012793   0.000538             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   44              0.000021           endif
   66              0.000053         endfor
   24              0.000013       endfor
                            
    2              0.000004       if empty(s:separators)
                                    " nothing to be done
                                    continue
    2              0.000002       endif
                                  " TODO: optimize this
   20              0.000051       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   18   0.013665   0.000206         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   20              0.000017       endfor
    2              0.000001     endif
    4              0.000016   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:31
Called 8 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    8              0.000045   if empty(s:client) || s:client['running'] == 0
                                return 0
    8              0.000005   endif
    8              0.000027   return 1

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 10 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
   10              0.000034   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   10              0.000041   let bomb     = &bomb ? '[BOM]' : ''
   10              0.000047   let noeolf   = &eol ? '' : '[!EOL]'
   10              0.000059   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   10              0.000059   if expected is# &fenc.bomb.noeolf.ff
                                return ''
   10              0.000008   else
   10              0.000030     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  119()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 8 times
Total time:   0.001511
 Self time:   0.000095

count  total (s)   self (s)
    8   0.000049   0.000027     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
    8              0.000003     endif
                            
    8   0.001444   0.000050     return self.equals(self.getNerdtree().root)

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 20 times
Total time:   0.000487
 Self time:   0.000473

count  total (s)   self (s)
   20              0.000393   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   18              0.000027     return a:arg
    2   0.000024   0.000010   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    2              0.000002   else
    2              0.000005     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 10 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
   10              0.000073   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   10              0.000278   return match(a:name, pat) > -1

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return s:available

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 8 times
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
    8              0.000159   let matches = matchlist(a:line, s:hunk_re)
    8              0.000031   if len(matches) > 0
    8              0.000045     let from_line  = str2nr(matches[1])
    8              0.000033     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    8              0.000020     let to_line    = str2nr(matches[3])
    8              0.000029     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    8              0.000023     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>134_job_id()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:104
Called 4 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
                              " Vim
    4              0.000083   return job_info(a:job).process

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 26 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
   26              0.000050   let x = a:i - 1
   28              0.000036   while x >= 0
   24              0.000067     let group = a:sections[x][0]
   24              0.000061     if group != '' && group != '|'
   22              0.000025       return group
    2              0.000003     endif
    2              0.000003     let x = x - 1
    6              0.000007   endwhile
    4              0.000002   return ''

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:493
Called 34 times
Total time:   0.005372
 Self time:   0.005129

count  total (s)   self (s)
   34              0.000038   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
   34              0.000019   else
   34              0.000111     let fileNodeExtension = fnamemodify(a:1, ':e')
   34              0.000086     let fileNode = fnamemodify(a:1, ':t')
   34              0.000030     if a:0 > 1
   12              0.000015       let isDirectory = a:2
   22              0.000013     else
   22              0.000025       let isDirectory = 0
   34              0.000022     endif
   34              0.000015   endif
                            
   34              0.000070   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   34              0.000050     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   34              0.000107     let fileNodeExtension = tolower(fileNodeExtension)
   34              0.000075     let fileNode = tolower(fileNode)
                            
  340              0.000732     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  306              0.001504       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  306              0.000123       endif
  340              0.000185     endfor
                            
   34              0.000068     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   34              0.000111       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
    8              0.000016         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   26              0.000110       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
    8              0.000020         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   18              0.000018       elseif isDirectory == 1
   10              0.000034         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   34              0.000017       endif
   34              0.000020     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   34              0.000016   endif
                            
   34   0.000488   0.000245   let artifactFix = s:DevIconsGetArtifactFix()
                            
   34              0.000049   return symbol . artifactFix
                            

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:82
Called 2 times
Total time:   0.000259
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000256   0.000025   return s:AsyncRequest(a:name, a:000)

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 10 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   10              0.000047   return get(s:parts, a:key, {})

FUNCTION  <SNR>140_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 44 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
   44              0.000091   if a:text ==# 'added'
    4              0.000005     return 'GitGutterLineAdded'
   40              0.000057   elseif a:text ==# 'removed'
    2              0.000003     return 'GitGutterLineRemoved'
   38              0.000063   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   38              0.000059   elseif a:text ==# 'modified'
   38              0.000045     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 10 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   10              0.000050   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 2 times
Total time:   0.001235
 Self time:   0.000736

count  total (s)   self (s)
    2              0.000011   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    2              0.000030     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    2   0.000055   0.000022     let modified_lines = s:handle_double_hunk(a:modified_lines)
    2   0.001083   0.000617     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    2              0.000006     if exists('*sign_placelist')
    2              0.000042       call sign_placelist(signs)
    2              0.000002       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>127_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 22 times
Total time:   0.001956
 Self time:   0.000692

count  total (s)   self (s)
   22              0.000104     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   22   0.000298   0.000114     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   22              0.000009     endif
   22              0.000019     if condition
                                  call a:builder.add_raw('%(')
   22              0.000015     endif
   22   0.001349   0.000269     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   22              0.000022     if condition
                                  call a:builder.add_raw('%)')
   22              0.000009     endif

FUNCTION  <SNR>138_process_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:302
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000003   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
    2              0.000001   else
    2              0.000020     call add(a:modifications, [a:to_line, 'removed'])
    2              0.000033   endif

FUNCTION  gitstatus#util#BuildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:59
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000018     let l:cmd = [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'status', '--porcelain' . (get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2 ? '=v2' : ''), '-z' ]
    2              0.000006     if has_key(a:opts, 'NERDTreeGitStatusUntrackedFilesMode')
    2              0.000010         let l:cmd += ['--untracked-files=' . a:opts['NERDTreeGitStatusUntrackedFilesMode']]
    2              0.000002     endif
                            
    2              0.000006     if get(a:opts, 'NERDTreeGitStatusShowIgnored', 0)
                                    let l:cmd += ['--ignored=traditional']
    2              0.000001     endif
                            
    2              0.000005     if has_key(a:opts, 'NERDTreeGitStatusIgnoreSubmodules')
                                    let l:cmd += ['--ignore-submodules=' . a:opts['NERDTreeGitStatusIgnoreSubmodules']]
    2              0.000001     endif
                            
    2              0.000002     return l:cmd

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 14 times
Total time:   0.000602
 Self time:   0.000242

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   14   0.000477   0.000117   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    4              0.000003     return ''
   10              0.000005   endif
   10              0.000028   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   10              0.000007   else
   10              0.000018     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:170
Called 90 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
   90              0.000265     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 48 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
   48              0.000157     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 16 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   16              0.000031   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   16              0.000070   let ggvars = getbufvar(buffer, 'gitgutter')
   16              0.000046   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   16              0.000014   endif
   16              0.000064   let ggvars[a:varname] = a:val

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 10 times
Total time:   0.001631
 Self time:   0.001334

count  total (s)   self (s)
   10              0.000059   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   10              0.000064   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   10              0.000005   endif
   10              0.000080   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   10              0.000050   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
   10              0.000006   endif
   10   0.000371   0.000074   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:157
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000004     let old_ei = &eventignore
    2              0.000002     if a:ignoreAll
    2              0.000021         set eventignore=all
    2              0.000001     endif
    2              0.000000     try
    2              0.000018         exec a:cmd
    2              0.000002     finally
    2              0.000008         let &eventignore = old_ei
    2              0.000002     endtry

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 16 times
Total time:   0.006669
 Self time:   0.000459

count  total (s)   self (s)
   16              0.000035   if a:group1 == a:group2
                                return 0
   16              0.000010   endif
   16   0.003155   0.000131   let color1 = airline#highlighter#get_highlight(a:group1)
   16   0.003351   0.000165   let color2 = airline#highlighter#get_highlight(a:group2)
   16              0.000088   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 2 times
Total time:   0.000042
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000033   0.000012   call <sid>check_defined_section(a:name)
    2              0.000008   let w:airline_section_{a:name} .= a:value

FUNCTION  <SNR>114_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:126
Called 104 times
Total time:   0.002460
 Self time:   0.002460

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  104              0.000349   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  104              0.000061   endif
  104              0.000348   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  104              0.000068   endif
                            
  104              0.000224   for val in a:colors
  104              0.000290     if !empty(val) && val !=# 'NONE'
  104              0.000109       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000011   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    2              0.000002   endif

FUNCTION  296()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 4 times
Total time:   0.026398
 Self time:   0.002831

count  total (s)   self (s)
    4              0.000004   let side = 1
    4              0.000004   let line = ''
    4              0.000003   let i = 0
    4              0.000009   let length = len(self._sections)
    4              0.000004   let split = 0
    4              0.000005   let is_empty = 0
    4              0.000006   let prev_group = ''
                            
   30              0.000047   while i < length
   26              0.000071     let section = self._sections[i]
   26              0.000054     let group = section[0]
   26              0.000052     let contents = section[1]
   26              0.000041     let pgroup = prev_group
   26   0.000590   0.000270     let prev_group = airline#builder#get_prev_group(self._sections, i)
   26              0.000076     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   26              0.000097     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000006       let group = 'airline_c'. self._context.bufnr
   24              0.000078     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000004       let prev_group = 'airline_c'. self._context.bufnr
   26              0.000018     endif
   26              0.000026     if is_empty
                                  let prev_group = pgroup
   26              0.000010     endif
   26   0.000539   0.000211     let is_empty = s:section_is_empty(self, contents)
                            
   26              0.000027     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   26              0.000015     endif
                            
   26              0.000037     if group == ''
                                  let line .= contents
   26              0.000037     elseif group == '|'
    4              0.000005       let side = 0
    4              0.000008       let line .= contents
    4              0.000005       let split = 1
   22              0.000012     else
   22              0.000034       if prev_group == ''
    4              0.000013         let line .= '%#'.group.'#'
   18              0.000015       elseif split
    2              0.000001         if !is_empty
    2   0.001862   0.000030           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000002         endif
    2              0.000004         let split = 0
   16              0.000009       else
   16              0.000017         if !is_empty
   16   0.019959   0.000177           let line .= s:get_seperator(self, prev_group, group, side)
   16              0.000009         endif
   22              0.000021       endif
   22   0.001575   0.000270       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   26              0.000020     endif
                            
   26              0.000047     let i = i + 1
   30              0.000045   endwhile
                            
    4              0.000005   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    2              0.000068     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    4              0.000002   endif
    4              0.000005   return line

FUNCTION  <SNR>45_buildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:145
Called 2 times
Total time:   0.000079
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000078   0.000019     return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)

FUNCTION  299()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:48
Called 2 times
Total time:   0.002334
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000003     let self.running = 0
    2              0.000002     if self.failed
                                    call self.onFailed()
    2              0.000001     else
    2   0.002321   0.000006         call self.onSuccess()
    2              0.000002     endif

FUNCTION  <SNR>138_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 8 times
Total time:   0.001974
 Self time:   0.000741

count  total (s)   self (s)
    8              0.000013   let modifications = []
    8              0.000018   let from_line  = a:hunk[0]
    8              0.000016   let from_count = a:hunk[1]
    8              0.000012   let to_line    = a:hunk[2]
    8              0.000016   let to_count   = a:hunk[3]
                            
    8   0.000106   0.000085   if s:is_added(from_count, to_count)
    2   0.000055   0.000019     call s:process_added(modifications, from_count, to_count, to_line)
    2   0.000099   0.000013     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    6   0.000055   0.000038   elseif s:is_removed(from_count, to_count)
    2   0.000082   0.000018     call s:process_removed(modifications, from_count, to_count, to_line)
    2   0.000234   0.000030     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    4   0.000037   0.000025   elseif s:is_modified(from_count, to_count)
    2   0.000085   0.000038     call s:process_modified(modifications, from_count, to_count, to_line)
    2   0.000120   0.000016     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    2   0.000032   0.000025   elseif s:is_modified_and_added(from_count, to_count)
    2   0.000421   0.000033     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    2   0.000137   0.000019     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    2   0.000144   0.000015     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    8              0.000005   endif
    8              0.000011   return modifications

FUNCTION  gitstatus#util#ParseGitStatusLine()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:174
Called 16 times
Total time:   0.000747
 Self time:   0.000583

count  total (s)   self (s)
   16              0.000058     if get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2
   16              0.000047         if a:statusLine[0] ==# '1'
   12   0.000269   0.000105             let l:statusKey = s:getStatusKey(a:statusLine[2], a:statusLine[3])
   12              0.000030             let l:pathStr = a:statusLine[113:]
    4              0.000006         elseif a:statusLine[0] ==# '2'
                                        let l:statusKey = 'Renamed'
                                        let l:pathStr = a:statusLine[113:]
                                        let l:pathStr = l:pathStr[stridx(l:pathStr, ' ')+1:]
    4              0.000005         elseif a:statusLine[0] ==# 'u'
                                        let l:statusKey = 'Unmerged'
                                        let l:pathStr = a:statusLine[161:]
    4              0.000007         elseif a:statusLine[0] ==# '?'
    4              0.000005             let l:statusKey = 'Untracked'
    4              0.000009             let l:pathStr = a:statusLine[2:]
                                    elseif a:statusLine[0] ==# '!'
                                        let l:statusKey = 'Ignored'
                                        let l:pathStr = a:statusLine[2:]
                                    else
                                        throw '[nerdtree_git_status] unknown status: ' . a:statusLine
   16              0.000006         endif
   16              0.000031         return [l:pathStr, l:statusKey]
                                else
                                    let l:pathStr = a:statusLine[3:]
                                    let l:statusKey = s:getStatusKey(a:statusLine[0], a:statusLine[1])
                                    return [l:pathStr, l:statusKey]
                                endif

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:245
Called 2 times
Total time:   0.008312
 Self time:   0.000011

count  total (s)   self (s)
    2   0.008311   0.000010     call b:NERDTree.render()

FUNCTION  128()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:288
Called 22 times
Total time:   0.014303
 Self time:   0.000154

count  total (s)   self (s)
   22   0.014298   0.000149     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  <SNR>45_hasPrefix()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:217
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000015     return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 2 times
Total time:   0.000059
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000057   0.000015   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000014   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 10 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
   10              0.000151   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   10              0.000020   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   10              0.000004   endif
   10              0.000008   return ''

FUNCTION  <SNR>140_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000020   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    2              0.000002   endif
                            
    2              0.000003   return a:modified_lines

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 20 times
Total time:   0.000481
 Self time:   0.000188

count  total (s)   self (s)
   20   0.000475   0.000182   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>45_onGitStatusSuccessCB()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:160
Called 2 times
Total time:   0.002280
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000012     if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
                                    call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
                                    return
    2              0.000002     endif
    2              0.000007     let l:output = join(a:job.chunks, '')
    2              0.000024     let l:lines = split(l:output, "\n")
    2   0.002085   0.000027     let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
                            
    2   0.000030   0.000012     call s:listener.SetNext(l:cache)
    2   0.000103   0.000008     call s:listener.TryUpdateNERDTreeUI()

FUNCTION  207()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 38 times
Total time:   0.000621
 Self time:   0.000384

count  total (s)   self (s)
   38   0.000377   0.000140     let flags = self._flagsForScope(a:scope)
   38              0.000092     if index(flags, a:flag) == -1
   38              0.000092         call add(flags, a:flag)
   38              0.000038     end

FUNCTION  208()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 68 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   68              0.000233     let self._flags[a:scope] = []

FUNCTION  209()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 72 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
   72              0.000159     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
   72              0.000036     endif
   72              0.000103     return self._flags[a:scope]

FUNCTION  coc#api#call()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:572
Called 8 times
Total time:   0.002483
 Self time:   0.000272

count  total (s)   self (s)
    8              0.000049   let err = v:null
    8              0.000021   let res = v:null
    8              0.000020   try
    8   0.002334   0.000123     let res = call(s:funcs[a:method], a:args)
                              catch /.*/
                                let err = v:exception
    8              0.000007   endtry
    8              0.000012   return [err, res]

FUNCTION  <SNR>114_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:183
Called 36 times
Total time:   0.026957
 Self time:   0.001722

count  total (s)   self (s)
   36              0.000076   if pumvisible()
                                return
   36              0.000015   endif
   36              0.000138   let group = a:from.'_to_'.a:to.a:suffix
   36   0.007686   0.000275   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   36   0.007459   0.000326   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   36              0.000047   if a:inverse
   14              0.000077     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   22              0.000010   else
   22              0.000113     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   36              0.000025   endif
   36              0.000130   let a:dict[group] = colors
   36   0.010995   0.000304   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>114_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:38
Called 832 times
Total time:   0.022103
 Self time:   0.022103

count  total (s)   self (s)
  832              0.001069   let color = ''
  832              0.003850   if hlexists(a:group)
  800              0.005819     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
  832              0.000576   endif
  832              0.002119   if empty(color) || color == -1
                                " should always exist
   32              0.000403     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
   32              0.000089     if empty(color) || color == -1
                                  let color = 'NONE'
   32              0.000022     endif
  832              0.000373   endif
  832              0.000817   return color

FUNCTION  <SNR>17_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:231
Called 6 times
Total time:   0.000725
 Self time:   0.000102

count  total (s)   self (s)
    6              0.000021   if !g:coc_workspace_initialized
                                return
    6              0.000005   endif
    6   0.000672   0.000049   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 10 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
   10              0.000067   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>134_on_stdout_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:79
Called 8 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    8              0.000019   call add(self.stdoutbuffer, a:data)

FUNCTION  212()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 20 times
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
   20              0.000023     let flagstring = ''
   60              0.000077     for i in values(self._flags)
   40              0.000092         let flagstring .= join(i)
   60              0.000037     endfor
                            
   20              0.000037     if len(flagstring) == 0
                                    return ''
   20              0.000010     endif
                            
   20              0.000035     return '[' . flagstring . ']'

FUNCTION  217()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 2 times
Total time:   0.000177
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000062   0.000005     call g:NERDTree.MustBeOpen()
    2   0.000113   0.000021     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  218()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 8 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    8              0.000020     return exists('b:NERDTree')

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:5
Called 2 times
Total time:   0.000555
 Self time:   0.000325

count  total (s)   self (s)
    2              0.000006   let line = getline(".")
    2              0.000004   let col = col('.')
    2              0.000024   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
                                let col = indent('.') + 1
    2              0.000001   endif
    2   0.000258   0.000028   let syn_start = s:syn_name(line('.'), col)
    2              0.000007   let save_cursor = getcurpos()
                            
    2              0.000022   if syn_start =~? '^jsx'
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
    2              0.000002   else
    2              0.000179     let &l:commentstring = a:original
    2              0.000002   endif
                            
                              " Restore the cursor position
    2              0.000010   call setpos('.', save_cursor)

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:58
Called 2 times
Total time:   0.000665
 Self time:   0.000665

count  total (s)   self (s)
    2              0.000664   let s:hl_groups = {}

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 2 times
Total time:   0.056418
 Self time:   0.000656

count  total (s)   self (s)
    2   0.000062   0.000015   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    2              0.000002   endif
                            
    2   0.000055   0.000014   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    2              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000003   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    2              0.000009   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    2              0.000005   let s:counter = (s:counter + 1) % 20
    2              0.000007   let buff_file .= '.'.s:counter
                            
    2   0.000230   0.000012   let extension = gitgutter#utility#extension(a:bufnr)
    2              0.000004   if !empty(extension)
    2              0.000006     let buff_file .= '.'.extension
    2              0.000000   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    2   0.052605   0.000133   call s:write_buffer(a:bufnr, buff_file)
                            
    2              0.000007   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    2              0.000015     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    2              0.000008     let from_file .= '.'.s:counter
                            
    2              0.000024     if !empty(extension)
    2              0.000004       let from_file .= '.'.extension
    2              0.000002     endif
                            
                                " Write file from index to temporary file.
    2   0.000538   0.000086     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000015     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000002   endif
                            
                              " Call git-diff.
    2              0.000007   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    2              0.000002   if s:c_flag
    2              0.000004     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000004     let cmd .= ' -c "diff.noprefix=false"'
    2              0.000004     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000000   endif
    2              0.000010   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    2              0.000006   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    2   0.000066   0.000015     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000000   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    2              0.000002   let cmd .= ' || exit 0'
                            
    2              0.000002   let cmd .= ')'
                            
    2   0.000636   0.000019   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    2   0.000019   0.000014   if g:gitgutter_async && gitgutter#async#available()
    2   0.001959   0.000100     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    2              0.000015     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  43()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 88 times
Total time:   0.003428
 Self time:   0.001497

count  total (s)   self (s)
   88   0.001878   0.000398     let l:separator = nerdtree#slash()
   88              0.000139     let l:leader = l:separator
                            
   88   0.000788   0.000337     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
   88              0.000040     endif
                            
   88              0.000341     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  223()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 8 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    8              0.000027     if exists('t:NERDTreeBufName')
    8              0.000136         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 6 times
Total time:   0.000162
 Self time:   0.000028

count  total (s)   self (s)
    6   0.000158   0.000024     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 2 times
Total time:   0.000057
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000053   0.000006     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    2              0.000001     endif

FUNCTION  229()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 30 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   30              0.000072     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
   30              0.000017     endif
   30              0.000031     return s:NERDTree._PathFilters

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:187
Called 10 times
Total time:   0.004931
 Self time:   0.000198

count  total (s)   self (s)
   10              0.000026   let bufnr = bufnr('')
   10   0.004896   0.000163   return gitgutter#utility#is_active(bufnr) ? gitgutter#hunk#summary(bufnr) : [0,0,0]

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 10 times
Total time:   0.000795
 Self time:   0.000430

count  total (s)   self (s)
   10   0.000786   0.000421   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>114_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:54
Called 208 times
Total time:   0.001303
 Self time:   0.001303

count  total (s)   self (s)
  208              0.001220   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000007   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    2              0.000001   endif

FUNCTION  <SNR>45_onCursorHold()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:187
Called 2 times
Total time:   0.001928
 Self time:   0.000198

count  total (s)   self (s)
                                " Do not update when a special buffer is selected
    2              0.000006     if !empty(&l:buftype)
                                    return
    2              0.000002     endif
    2              0.000008     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
                            
    2   0.000032   0.000016     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    2              0.000001     endif
                            
    2   0.001669   0.000080     let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
    2   0.000204   0.000079     call s:logger.debug('run cursor-hold job: ' . l:job.id)

FUNCTION  <SNR>134_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000007   if has('unix')
    2              0.000005     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 2 times
Total time:   0.000204
 Self time:   0.000064

count  total (s)   self (s)
    2   0.000120   0.000018   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000006   let summary[2] += a:count
    2   0.000077   0.000039   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>55_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 2 times
Total time:   0.000061
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000012   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    2              0.000002   endif
    2   0.000036   0.000019   call airline#update_tabline()

FUNCTION  232()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 2 times
Total time:   0.008301
 Self time:   0.000012

count  total (s)   self (s)
    2   0.008301   0.000012     call self.ui.render()

FUNCTION  234()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 2 times
Total time:   0.000266
 Self time:   0.000259

count  total (s)   self (s)
    2   0.000014   0.000010     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    2   0.000012   0.000009     elseif !self.isMinimal()
    2              0.000007         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
    2              0.000011         silent! put =help
    2              0.000001     endif

FUNCTION  239()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002     return self._showBookmarks

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 2 times
Total time:   0.001859
 Self time:   0.001704

count  total (s)   self (s)
    2   0.000096   0.000020   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000011   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000051   0.000037   let command = s:build_command(a:cmd)
                            
    2              0.000007   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    2              0.000002   else
    2              0.001427     let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    2   0.000225   0.000160     let s:jobs[s:job_id(job)] = 1
    2              0.000003   endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 2 times
Total time:   0.004387
 Self time:   0.000229

count  total (s)   self (s)
    2   0.000074   0.000012   call gitgutter#debug#log(a:diff)
                            
    2              0.000004   if !bufexists(a:bufnr)
                                return
    2              0.000001   endif
                            
    2   0.000718   0.000035   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.002159   0.000035   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000006   let signs_count = len(modified_lines)
    2              0.000006   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    2              0.000002   else
    2              0.000006     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    2   0.001288   0.000053       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000001     endif
    2              0.000002   endif
                            
    2   0.000077   0.000023   call s:save_last_seen_change(a:bufnr)
    2              0.000011   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    2              0.000002   endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 2 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000046   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    2              0.000005   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    2              0.000005   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    2              0.000001   endif
                            
    2              0.000005   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    2              0.000000   endif

FUNCTION  <SNR>138_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000006   let offset = 0
    4              0.000007   while offset < a:to_count
    2              0.000005     let line_number = a:to_line + offset
    2              0.000010     call add(a:modifications, [line_number, 'modified'])
    2              0.000003     let offset += 1
    4              0.000004   endwhile

FUNCTION  240()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 20 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
   20              0.000017     return self._showFiles

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 30 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
   30              0.000030     return self._showHidden

FUNCTION  245()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 32 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   32              0.000033     return self._ignoreEnabled ==# 1

FUNCTION  246()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 6 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    6              0.000006     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 4 times
Total time:   0.000204
 Self time:   0.000063

count  total (s)   self (s)
    4   0.000100   0.000022   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000010   let summary[0] += a:count
    4   0.000089   0.000026   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>136_syn_name()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:32
Called 2 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
    2              0.000202   let syn_id = get(synstack(a:lnum, a:cnum), -1)
    2              0.000008   return synIDattr(syn_id, "name")

FUNCTION  <SNR>109_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:177
Called 4 times
Total time:   0.031016
 Self time:   0.000244

count  total (s)   self (s)
    4   0.000119   0.000020   let builder = airline#builder#new(a:context)
    4   0.004337   0.000062   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    4              0.000004   if err == 1
    4   0.026427   0.000029     let a:context.line = builder.build()
    4              0.000034     let s:contexts[a:context.winnr] = a:context
    4              0.000017     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    4              0.000071     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    4              0.000003   endif

FUNCTION  <SNR>45_refreshGitStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:149
Called 2 times
Total time:   0.001589
 Self time:   0.000117

count  total (s)   self (s)
    2              0.000020     let l:opts =  { 'on_failed_cb': function('s:onGitStatusFailedCB'), 'on_success_cb': function('s:onGitStatusSuccessCB'), 'cwd': a:workdir }
    2   0.001541   0.000069     let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
    2              0.000009     return l:job

FUNCTION  gitstatus#shouldConceal()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:67
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000011     return has('conceal') && g:NERDTreeGitStatusConcealBrackets

FUNCTION  253()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 2 times
Total time:   0.008289
 Self time:   0.000318

count  total (s)   self (s)
    2              0.000021     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    2              0.000006     let curLine = line('.')
    2              0.000004     let curCol = col('.')
    2              0.000005     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    2              0.000056     silent 1,$delete _
                            
    2   0.000277   0.000011     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    2   0.000008   0.000005     if !self.isMinimal()
    2              0.000009         call setline(line('.')+1, '')
    2              0.000008         call cursor(line('.')+1, col('.'))
    2              0.000001     endif
                            
    2   0.000009   0.000007     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    2              0.000001     endif
                            
                                " add the 'up a dir' line
    2   0.000007   0.000005     if !self.isMinimal()
    2   0.000017   0.000015         call setline(line('.')+1, s:UI.UpDirLine())
    2              0.000006         call cursor(line('.')+1, col('.'))
    2              0.000002     endif
                            
                                " draw the header line
    2   0.000305   0.000018     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    2              0.000008     call setline(line('.')+1, header)
    2              0.000007     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    2   0.007440   0.000031     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    2              0.000010     silent 1,1delete _
                            
                                " restore the view
    2              0.000004     let old_scrolloff=&scrolloff
    2              0.000011     let &scrolloff=0
    2              0.000005     call cursor(topLine, 1)
    2              0.000019     normal! zt
    2              0.000004     call cursor(curLine, curCol)
    2              0.000008     let &scrolloff = old_scrolloff
                            
    2              0.000010     setlocal readonly nomodifiable

FUNCTION  <SNR>134_on_exit_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:87
Called 2 times
Total time:   0.004533
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000007   let job = ch_getjob(a:channel)
    2   0.000044   0.000013   let jobid = s:job_id(job)
    2              0.000014   if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
    2              0.000002   while 1
    2              0.000006     if job_status(job) == 'dead'
    2              0.000012       let exit_code = job_info(job).exitval
    2              0.000002       break
                                endif
                                sleep 5m
    2              0.000003   endwhile
                            
    2              0.000002   if !exit_code
    2   0.004431   0.000044     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    2              0.000002   endif

FUNCTION  <SNR>115_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 10 times
Total time:   0.005168
 Self time:   0.000154

count  total (s)   self (s)
   10   0.000165   0.000082   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
   10              0.000007   endif
   10   0.004978   0.000047   return GitGutterGetHunkSummary()

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:190
Called 14 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   14              0.000109   if has_key(s:contexts, a:winnr)
   14              0.000148     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 14 times
Total time:   0.005960
 Self time:   0.000563

count  total (s)   self (s)
   14   0.005948   0.000551   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>70_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/vim/8.2.2475/share/vim/vim82/plugin/matchparen.vim:40
Called 2 times
Total time:   0.000220
 Self time:   0.000205

count  total (s)   self (s)
                              " Remove any previous match.
    2   0.000027   0.000012   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000010   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    2              0.000002   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000005   let c_lnum = line('.')
    2              0.000005   let c_col = col('.')
    2              0.000002   let before = 0
                            
    2              0.000007   let text = getline(c_lnum)
    2              0.000054   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000004   if empty(matches)
                                let [c_before, c] = ['', '']
    2              0.000000   else
    2              0.000012     let [c_before, c] = matches[1:2]
    2              0.000001   endif
    2              0.000036   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000006   let i = index(plist, c)
    2              0.000002   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000006     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    2              0.000000     endif
    2              0.000000     if i < 0
                                  " not found, nothing to do
    2              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  261()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002     return '.. (up a dir)'

FUNCTION  262()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 34 times
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
   34              0.000085     let newObj = copy(self)
   34              0.000061     let newObj.nerdtree = a:nerdtree
   34              0.000057     let newObj.subject = a:subject
   34              0.000053     let newObj.action = a:action
   34              0.000054     let newObj.params = a:params
   34              0.000030     return newObj

FUNCTION  264()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 34 times
Total time:   0.020253
 Self time:   0.001635

count  total (s)   self (s)
   34   0.000544   0.000178     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  102   0.000750   0.000292     for Listener in s:Notifier.GetListenersForEvent(a:event)
   68              0.000471         let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
   68   0.018130   0.000336         call l:Callback(event)
  102              0.000076     endfor

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 34 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   34              0.000120     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
   34              0.000015     endif
   34              0.000037     return s:refreshListenersMap

FUNCTION  266()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 34 times
Total time:   0.000458
 Self time:   0.000237

count  total (s)   self (s)
   34   0.000343   0.000122     let listenersMap = s:Notifier.GetListenersMap()
   34              0.000095     return get(listenersMap, a:name, [])

FUNCTION  267()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:24
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000008     if a:level < self.level
    2              0.000002         return
                                endif
                                echomsg '[nerdtree-git-status] ' . a:msg

FUNCTION  268()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:31
Called 2 times
Total time:   0.000125
 Self time:   0.000113

count  total (s)   self (s)
    2   0.000123   0.000111     echohl LineNr | call self.output(s:debug, a:msg) | echohl None

FUNCTION  <SNR>126_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 26 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
   26              0.000039   let start=1
                            
                              " do not check for inactive windows or the tabline
   26              0.000045   if a:self._context.active == 0
    8              0.000007     return 0
   18              0.000055   elseif get(a:self._context, 'tabline', 0)
                                return 0
   18              0.000012   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   18              0.000053   if get(g:, 'airline_skip_empty_sections', 0) == 0
   18              0.000019     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:62
Called 208 times
Total time:   0.039036
 Self time:   0.015630

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
  208              0.001885   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  208              0.000866   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  208              0.000177   else
  208   0.007474   0.001557     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  208   0.006950   0.001432     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  208   0.006697   0.001364     let guifg = s:get_syn(a:group, 'fg', 'gui')
  208   0.006656   0.001321     let guibg = s:get_syn(a:group, 'bg', 'gui')
  208              0.001333     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  208              0.000217     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  208              0.000137     else
  208   0.003177   0.001874       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  208              0.000129     endif
  208              0.000096   endif
  208              0.000715   let s:hl_groups[a:group] = res
  208              0.000185   return res

FUNCTION  <SNR>52_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 14 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   14              0.000077   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>133_newJob()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:30
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000024     return extend(deepcopy(s:Job), { 'name': a:name, 'opts': a:opts })

FUNCTION  274()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:31
Called 34 times
Total time:   0.005158
 Self time:   0.000111

count  total (s)   self (s)
   34   0.005151   0.000104     call self.callback(a:event)

FUNCTION  275()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:35
Called 34 times
Total time:   0.005047
 Self time:   0.000623

count  total (s)   self (s)
   34              0.000059     let l:path = a:event.subject
   34   0.004362   0.000133     let l:indicator = self.getIndicatorByPath(l:path)
   34   0.000243   0.000121     call l:path.flagSet.clearFlags('git')
   34              0.000056     if l:indicator !=# ''
    4   0.000028   0.000015         if gitstatus#shouldConceal()
                                        let l:indicator = printf(' %s ', l:indicator)
    4              0.000002         endif
    4   0.000075   0.000015         call l:path.flagSet.addFlag('git', l:indicator)
   34              0.000014     endif

FUNCTION  276()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:47
Called 34 times
Total time:   0.004229
 Self time:   0.000848

count  total (s)   self (s)
   34   0.003319   0.000175     let l:pathStr = gitstatus#util#FormatPath(a:path)
   34              0.000108     let l:statusKey = get(self.current, l:pathStr, '')
                            
   34              0.000050     if l:statusKey !=# ''
    4   0.000048   0.000019         return gitstatus#getIndicator(l:statusKey)
   30              0.000011     endif
                            
   30   0.000220   0.000109     if self.getOption('ShowClean', 0)
                                    return gitstatus#getIndicator('Clean')
   30              0.000020     endif
                            
   30   0.000225   0.000128     if self.getOption('ConcealBrackets', 0) && self.getOption('AlignIfConceal', 0)
                                    return ' '
   30              0.000015     endif
   30              0.000019     return ''

FUNCTION  277()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:65
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000017     let self.next = a:cache

FUNCTION  279()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:73
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000009     return self.current !=# self.next

FUNCTION  <SNR>138_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 2 times
Total time:   0.000054
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000054   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  241()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003     return self._showHelp

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:223
Called 2 times
Total time:   0.000598
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000006   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    2              0.000000   else
    2              0.000023     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    2              0.000000   endif
                            
    2              0.000002   if !empty(colors)
    2   0.000554   0.000017     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    2              0.000001   endif

FUNCTION  gitstatus#util#UpdateParentDirsStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:203
Called 16 times
Total time:   0.000601
 Self time:   0.000601

count  total (s)   self (s)
   16              0.000054     let l:dirtyPath = fnamemodify(a:pathStr, ':h')
   16              0.000054     let l:dir_dirty_only = get(a:opts, 'NERDTreeGitStatusDirDirtyOnly', 1)
   26              0.000056     while l:dirtyPath !=# a:root
   22              0.000062         let l:key = get(a:cache, l:dirtyPath, '')
   22              0.000026         if l:dir_dirty_only
   22              0.000023             if l:key ==# ''
   10              0.000025                 let a:cache[l:dirtyPath] = 'Dirty'
   12              0.000008             else
   12              0.000009                 return
   10              0.000004             endif
                                    else
                                        if l:key ==# ''
                                            let a:cache[l:dirtyPath] = a:statusKey
                                        elseif l:key ==# 'Dirty' || l:key ==# a:statusKey
                                            return
                                        else
                                            let a:cache[l:dirtyPath] = 'Dirty'
                                        endif
   10              0.000006         endif
   10              0.000045         let l:dirtyPath = fnamemodify(l:dirtyPath, ':h')
   14              0.000017     endwhile

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 10 times
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
   10              0.000050   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   10              0.000044     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   10              0.000039     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   10              0.000030     let default = get(g:, 'airline#extensions#keymap#default', '')
   10              0.000034     if (label !=# '')
   10              0.000021       let label .= ' '
   10              0.000004     endif
   10              0.000013     let keymap = &keymap
   10              0.000022     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   10              0.000007     endif
   10              0.000072     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  281()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:81
Called 2 times
Total time:   0.000095
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000072   0.000013     if !g:NERDTree.IsOpen()
                                    return
    2              0.000001     endif
                            
    2   0.000016   0.000007     if !self.changed()
    2              0.000000         return
                                endif
                            
                                call self.update()
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                try
                                    call g:NERDTree.CursorToTreeWin()
                                    call b:NERDTree.root.refreshFlags()
                                    call NERDTreeRender()
                                finally
                                    noautocmd exec l:altwinnr . 'wincmd w'
                                    noautocmd exec l:winnr . 'wincmd w'
                                endtry

FUNCTION  289()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000014   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:95
Called 8 times
Total time:   0.000788
 Self time:   0.000153

count  total (s)   self (s)
    8   0.000150   0.000046   if !coc#rpc#ready()
                                return ''
    8              0.000005   endif
    8   0.000603   0.000072   call s:client['notify'](a:method, a:args)
    8              0.000008   return ''

FUNCTION  <SNR>17_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:112
Called 2 times
Total time:   0.000231
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000018   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    2              0.000009   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    2              0.000001   endif
    2   0.000181   0.000016   call coc#rpc#notify(a:name, a:args)
    2              0.000001   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 10 times
Total time:   0.007641
 Self time:   0.001529

count  total (s)   self (s)
   10              0.000032   if !get(w:, 'airline_active', 0)
                                return ''
   10              0.000004   endif
                              " Cache values, so that it isn't called too often
   10   0.000384   0.000263   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   10              0.000007   endif
   10   0.005647   0.000090   let hunks = airline#extensions#hunks#get_raw_hunks()
   10              0.000013   let string = ''
   10   0.000120   0.000069   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   10              0.000022   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
   40              0.000059     for i in [0, 1, 2]
   30   0.000494   0.000236       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
   30              0.000203         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
   30              0.000018       endif
   40              0.000032     endfor
   10              0.000009   endif
   10   0.000169   0.000128   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
   10              0.000044     let string = string[0:-2]
   10              0.000005   endif
                            
   10              0.000017   let b:airline_hunks = string
   10              0.000027   let b:airline_changenr = b:changedtick
   10   0.000160   0.000076   let s:airline_winwidth = airline#util#winwidth()
   10              0.000008   return string

FUNCTION  291()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 22 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
   22              0.000078   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000003   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    2              0.000002   endif

FUNCTION  297()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:37
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000013     let self.chunks[-1] .= a:data[0]
    2              0.000008     call extend(self.chunks, a:data[1:])

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 48 times
Total time:   0.000711
 Self time:   0.000711

count  total (s)   self (s)
   48              0.000229   let ggvars = getbufvar(a:buffer, 'gitgutter')
   48              0.000311   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   34              0.000070     return ggvars[a:varname]
   14              0.000008   endif
   14              0.000009   if a:0
   14              0.000011     return a:1
                              endif

FUNCTION  <SNR>128_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 2 times
Total time:   0.000032
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000032   0.000014   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 50 times
Total time:   0.000457
 Self time:   0.000457

count  total (s)   self (s)
   50              0.000146   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   50              0.000033   endif
   50              0.000210   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>126_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 22 times
Total time:   0.001305
 Self time:   0.001305

count  total (s)   self (s)
   22              0.000034   if a:self._context.active
                                " active window
   16              0.000025     let contents = []
   16              0.000128     let content_parts = split(a:contents, '__accent')
   44              0.000060     for cpart in content_parts
   28              0.000222       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   28              0.000099       call add(contents, cpart)
   44              0.000038     endfor
   16              0.000055     let line = join(contents, a:group)
   16              0.000160     let line = substitute(line, '__restore__', a:group, 'g')
    6              0.000004   else
                                " inactive window
    6              0.000083     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
    6              0.000038     let line = substitute(line, '%#__restore__#', '', 'g')
   22              0.000016   endif
   22              0.000024   return line

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:156
Called 2 times
Total time:   0.008033
 Self time:   0.000133

count  total (s)   self (s)
    2   0.000082   0.000009   if airline#util#stl_disabled(winnr())
                                return
    2              0.000002   endif
    4              0.000008   for nr in a:range
    2   0.000056   0.000009     if airline#util#stl_disabled(nr)
                                  continue
    2              0.000000     endif
    2              0.000007     call setwinvar(nr, 'airline_active', 0)
    2              0.000009     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    2              0.000005     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    2              0.000001     endif
    2   0.007811   0.000031     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    4              0.000007   endfor

FUNCTION  <SNR>128_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 4 times
Total time:   0.000186
 Self time:   0.000044

count  total (s)   self (s)
    4   0.000183   0.000041   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000018     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  gitstatus#util#ParseGitStatusLines()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:82
Called 2 times
Total time:   0.002058
 Self time:   0.000710

count  total (s)   self (s)
    2              0.000006     let l:result = {}
    2              0.000002     let l:is_rename = 0
   18              0.000023     for l:line in a:statusLines
   16              0.000016         if l:is_rename
                                        call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, a:root . '/' . l:line, 'Dirty', a:opts)
                                        let l:is_rename = 0
                                        continue
   16              0.000009         endif
   16   0.000914   0.000167         let [l:pathStr, l:statusKey] = gitstatus#util#ParseGitStatusLine(l:line, a:opts)
                            
   16              0.000041         let l:pathStr = a:root . '/' . l:pathStr
   16              0.000038         if l:pathStr[-1:-1] is# '/'
                                        let l:pathStr = l:pathStr[:-2]
   16              0.000010         endif
   16              0.000029         let l:is_rename = l:statusKey is# 'Renamed'
   16              0.000038         let l:result[l:pathStr] = l:statusKey
                            
   16   0.000756   0.000155         call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, l:pathStr, l:statusKey, a:opts)
   18              0.000015     endfor
    2              0.000002     return l:result

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:500
Called 10 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   10              0.000033   return s:loaded_ext

FUNCTION  <SNR>138_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 2 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
    2              0.000005   let offset = 0
   38              0.000062   while offset < a:from_count
   36              0.000063     let line_number = a:to_line + offset
   36              0.000132     call add(a:modifications, [line_number, 'modified'])
   36              0.000047     let offset += 1
   38              0.000026   endwhile
    4              0.000005   while offset < a:to_count
    2              0.000004     let line_number = a:to_line + offset
    2              0.000006     call add(a:modifications, [line_number, 'added'])
    2              0.000003     let offset += 1
    4              0.000005   endwhile

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 2 times
Total time:   0.000157
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000102   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000053   0.000014   call s:reset_summary(a:bufnr)

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 4 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    4              0.000032   let builder = copy(s:prototype)
    4              0.000007   let builder._context = a:context
    4              0.000006   let builder._sections = []
                            
    4              0.000040   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    4              0.000004   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   0.058545   0.000463  gitgutter#process_buffer()
    2   0.058153   0.000485  gitgutter#all()
    2   0.056418   0.000656  gitgutter#diff#run_diff()
    2   0.052472             <SNR>138_write_buffer()
   14   0.040508   0.001780  airline#check_mode()
  208   0.039036   0.015630  airline#highlighter#get_highlight()
    2   0.037878   0.005258  airline#highlighter#highlight()
    2   0.032899   0.000088  <SNR>55_on_focus_gained()
    2   0.032768   0.000143  <SNR>55_airline_refresh()
    2   0.031560   0.000221  airline#update_statusline()
    2   0.031560   0.000117  <SNR>50_CursorHoldUpdate()
    4   0.031016   0.000244  <SNR>109_invoke_funcrefs()
  104   0.029891   0.006800  airline#highlighter#exec()
   12   0.029457   0.006139  162()
   36   0.026957   0.001722  <SNR>114_exec_separator()
    4   0.026398   0.002831  296()
   34   0.022342   0.000309  36()
  832   0.022103             <SNR>114_get_syn()
   34   0.020253   0.001635  264()
   16   0.019782   0.000305  <SNR>126_get_seperator()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2              0.052472  <SNR>138_write_buffer()
  832              0.022103  <SNR>114_get_syn()
  208   0.039036   0.015630  airline#highlighter#get_highlight()
   22   0.010246   0.007888  131()
  104   0.029891   0.006800  airline#highlighter#exec()
   12   0.029457   0.006139  162()
    2   0.037878   0.005258  airline#highlighter#highlight()
   34   0.005372   0.005129  WebDevIconsGetFileTypeSymbol()
   34              0.004380  <SNR>52_abs_path()
   90   0.008022   0.004272  38()
   34   0.012636   0.003183  NERDTreeWebDevIconsRefreshListener()
    4   0.026398   0.002831  296()
  104              0.002460  <SNR>114_CheckDefined()
    2              0.002053  <SNR>139_execute()
   14   0.040508   0.001780  airline#check_mode()
   36   0.026957   0.001722  <SNR>114_exec_separator()
    2   0.001859   0.001704  gitgutter#async#execute()
   34   0.020253   0.001635  264()
  104              0.001566  <SNR>114_hl_group_exists()
   10   0.007641   0.001529  airline#extensions#hunks#get_hunks()

